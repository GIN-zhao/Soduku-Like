<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°ç‹¬ - Sudoku</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: white;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-layout {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        .board-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .sudoku-board {
            display: grid;
            grid-template-columns: 30px repeat(9, 1fr);
            gap: 2px;
            background: #333;
            border: 3px solid #333;
            margin: 0 auto;
            max-width: 650px;
        }

        .cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            position: relative;
        }

        .row-label,
        .col-label {
            display: flex;
            align-items: center;
            justify-content: center;
            background: #78909c;
            color: white;
            font-size: 11px;
            font-weight: bold;
            position: relative;
            flex-direction: column;
            gap: 1px;
        }

        .row-label {
            font-size: 10px;
            line-height: 1.1;
        }

        .line-number {
            font-size: 14px;
            font-weight: bold;
        }

        .reward-number {
            font-size: 13px;
            font-weight: bold;
            color: #ffeb3b;
            background: rgba(0, 0, 0, 0.2);
            padding: 2px 4px;
            border-radius: 3px;
            margin: 1px 0;
        }

        .refresh-count {
            font-size: 8px;
            color: #b0bec5;
            margin-top: 1px;
        }

        .refresh-count.zero {
            color: #f44336;
        }

        .corner-label {
            background: #546e7a;
        }

        .cell:hover {
            transform: scale(1.05);
            z-index: 10;
        }

        .cell.empty {
            background: #f0f0f0;
        }

        .cell.number {
            background: #e3f2fd;
        }

        .cell.monster {
            background: #ffebee;
        }

        .cell.monster::after {
            content: 'ğŸ‘¹';
            position: absolute;
            font-size: 16px;
            top: 2px;
            right: 2px;
        }

        .cell.frozen {
            background: #e1f5fe;
            border: 2px solid #00bcd4;
        }

        .cell.selected {
            border: 3px solid #ff9800 !important;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
        }

        .cell.targeted {
            border: 3px solid #f44336 !important;
            box-shadow: 0 0 15px rgba(244, 67, 54, 0.7);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        .cell.box-border-right {
            border-right: 3px solid #333;
        }

        .cell.box-border-bottom {
            border-bottom: 3px solid #333;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .panel h2 {
            font-size: 18px;
            margin-bottom: 10px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .stats {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        .stat {
            padding: 8px;
            background: #f5f5f5;
            border-radius: 5px;
            text-align: center;
        }

        .stat-label {
            font-size: 12px;
            color: #666;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }

        .inventory {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .inventory-item {
            padding: 10px;
            background: #f5f5f5;
            border-radius: 5px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .inventory-item:hover {
            background: #e3f2fd;
        }

        .inventory-item.selected {
            border-color: #ff9800;
            background: #fff3e0;
        }

        .inventory-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .inventory-count {
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: #78909c;
            color: white;
        }

        .btn-secondary:hover {
            background: #607d8b;
        }

        .btn-danger {
            background: #ef5350;
            color: white;
        }

        .btn-danger:hover {
            background: #e53935;
        }

        .game-log {
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            padding: 5px;
            margin-bottom: 5px;
            background: #f5f5f5;
            border-radius: 3px;
            border-left: 3px solid #667eea;
        }

        .log-entry.danger {
            border-left-color: #f44336;
        }

        .log-entry.success {
            border-left-color: #4caf50;
        }

        .log-entry.warning {
            border-left-color: #ff9800;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px;
            border: 2px solid #667eea;
            background: white;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // æ¸¸æˆå¸¸é‡
        const BOARD_SIZE = 9;
        const INITIAL_HP = 100;
        const INITIAL_REFRESH_COUNT = 1;  // é™ä½åˆå§‹åˆ·æ–°æ¬¡æ•°
        const INITIAL_INVENTORY = {
            1: 3, 2: 3, 3: 3, 4: 2, 5: 2, 6: 2, 7: 2, 8: 1, 9: 1  // å¢åŠ åˆå§‹åº“å­˜
        };

        // æ ¼å­ç±»å‹
        const CELL_TYPE = {
            EMPTY: 'empty',
            NUMBER: 'number',
            MONSTER: 'monster'
        };

        // æ€ªç‰©ç±»å‹
        const MONSTER_TYPE = {
            NORMAL: 'normal',
            ELITE: 'elite',
            BOSS: 'boss'
        };

        // åŒºåŸŸç±»å‹
        const AREA_TYPE = {
            FARM: 'farm',      // æ¯å›åˆæ²»ç–—2
            MINE: 'mine',      // æ¯å›åˆè·å–2ä¸ªéšæœºæ•°å­—
            FACTORY: 'factory' // æ¯å›åˆè·å¾—åˆ†æ•°
        };

        // åˆå§‹åŒ–æ£‹ç›˜
        const initializeBoard = () => {
            const board = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                board[i] = [];
                for (let j = 0; j < BOARD_SIZE; j++) {
                    board[i][j] = {
                        value: 0,
                        type: CELL_TYPE.EMPTY,
                        monsterType: null,
                        frozenTurns: 0
                    };
                }
            }
            return board;
        };

        // åˆå§‹åŒ–åˆ·æ–°æ¬¡æ•°
        const initializeRefreshCounts = () => {
            return {
                rows: Array(BOARD_SIZE).fill(INITIAL_REFRESH_COUNT),
                cols: Array(BOARD_SIZE).fill(INITIAL_REFRESH_COUNT)
            };
        };

        // åˆå§‹åŒ–è¡Œåˆ—å¥–åŠ±æ•°å­—ï¼ˆéšæœºï¼‰
        const initializeLineRewards = () => {
            const rowRewards = [];
            const colRewards = [];
            for (let i = 0; i < BOARD_SIZE; i++) {
                // éšæœºç”Ÿæˆå¥–åŠ±æ•°å­—ï¼ˆ1-9ï¼‰å’Œæ•°é‡ï¼ˆ1-3ï¼‰
                rowRewards.push({
                    number: Math.floor(Math.random() * 9) + 1,
                    count: Math.floor(Math.random() * 3) + 1  // 1-3ä¸ª
                });
                colRewards.push({
                    number: Math.floor(Math.random() * 9) + 1,
                    count: Math.floor(Math.random() * 3) + 1  // 1-3ä¸ª
                });
            }
            return { rows: rowRewards, cols: colRewards };
        };

        // åˆå§‹åŒ–ä¹å®«æ ¼åŒºåŸŸ
        const initializeBoxAreas = () => {
            const areas = [];
            // ä¸ºæ‰€æœ‰9ä¸ªä¹å®«æ ¼åˆ†é…åŒºåŸŸï¼š3å†œåœºã€3çŸ¿æ´ã€3å·¥å‚
            const areaTypes = [
                AREA_TYPE.FARM, AREA_TYPE.FARM, AREA_TYPE.FARM,
                AREA_TYPE.MINE, AREA_TYPE.MINE, AREA_TYPE.MINE,
                AREA_TYPE.FACTORY, AREA_TYPE.FACTORY, AREA_TYPE.FACTORY
            ];

            // éšæœºæ‰“ä¹±
            for (let i = areaTypes.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [areaTypes[i], areaTypes[j]] = [areaTypes[j], areaTypes[i]];
            }

            for (let i = 0; i < 9; i++) {
                areas.push(areaTypes[i]);
            }

            return areas;
        };

        // æ£€æŸ¥æ˜¯å¦åœ¨ä¹å®«æ ¼è¾¹ç•Œï¼ˆç”¨äºæ˜¾ç¤ºè¾¹æ¡†ï¼‰
        const isBoxBorder = (row, col) => {
            return {
                right: (col + 1) % 3 === 0 && col < 8,
                bottom: (row + 1) % 3 === 0 && row < 8
            };
        };

        // è·å–ä¹å®«æ ¼ç´¢å¼•
        const getBoxIndex = (row, col) => {
            return Math.floor(row / 3) * 3 + Math.floor(col / 3);
        };

        // æ£€æŸ¥åœ¨æŸä¸ªä½ç½®æ”¾ç½®æ•°å­—æ˜¯å¦æœ‰æ•ˆ
        const isValidPlacement = (board, row, col, value) => {
            // æ£€æŸ¥è¡Œ
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (board[row][c].value === value) {
                    return false;
                }
            }
            // æ£€æŸ¥åˆ—
            for (let r = 0; r < BOARD_SIZE; r++) {
                if (board[r][col].value === value) {
                    return false;
                }
            }
            // æ£€æŸ¥ä¹å®«æ ¼
            const boxStartRow = Math.floor(row / 3) * 3;
            const boxStartCol = Math.floor(col / 3) * 3;
            for (let r = boxStartRow; r < boxStartRow + 3; r++) {
                for (let c = boxStartCol; c < boxStartCol + 3; c++) {
                    if (board[r][c].value === value) {
                        return false;
                    }
                }
            }
            return true;
        };

        // æ£€æŸ¥æŸä¸ªä½ç½®æ˜¯å¦å·²ç»é€ æˆå†²çªï¼ˆè¿”å›å†²çªæ•°é‡ï¼‰
        const checkConflictsAt = (board, row, col) => {
            const value = board[row][col].value;
            if (value === 0) return 0;

            let conflicts = 0;

            // æ£€æŸ¥è¡Œå†²çª
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (c !== col && board[row][c].value === value) {
                    conflicts++;
                }
            }

            // æ£€æŸ¥åˆ—å†²çª
            for (let r = 0; r < BOARD_SIZE; r++) {
                if (r !== row && board[r][col].value === value) {
                    conflicts++;
                }
            }

            // æ£€æŸ¥ä¹å®«æ ¼å†²çª
            const boxStartRow = Math.floor(row / 3) * 3;
            const boxStartCol = Math.floor(col / 3) * 3;
            for (let r = boxStartRow; r < boxStartRow + 3; r++) {
                for (let c = boxStartCol; c < boxStartCol + 3; c++) {
                    if ((r !== row || c !== col) && board[r][c].value === value) {
                        conflicts++;
                    }
                }
            }

            return conflicts;
        };

        // ç”Ÿæˆåˆå§‹æ•°ç‹¬å¸ƒå±€
        const generateInitialSudoku = (board) => {
            const newBoard = board.map(row => row.map(cell => ({ ...cell })));

            // ä¸ºæ¯ä¸ªæ ¼å­å°è¯•ç”Ÿæˆæ•°å­—ï¼ˆçº¦30-40%çš„æ ¼å­ä¼šæœ‰åˆå§‹æ•°å­—ï¼‰
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    // 35%çš„æ¦‚ç‡ç”Ÿæˆæ•°å­—
                    if (Math.random() < 0.35) {
                        // å°è¯•æ”¾ç½®ä¸€ä¸ªéšæœºæ•°å­—
                        const attempts = [];
                        for (let num = 1; num <= 9; num++) {
                            attempts.push(num);
                        }
                        // éšæœºæ‰“ä¹±å°è¯•é¡ºåº
                        for (let i = attempts.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            [attempts[i], attempts[j]] = [attempts[j], attempts[i]];
                        }

                        // å°è¯•æ”¾ç½®
                        for (const num of attempts) {
                            if (isValidPlacement(newBoard, row, col, num)) {
                                newBoard[row][col] = {
                                    value: num,
                                    type: CELL_TYPE.NUMBER,
                                    monsterType: null,
                                    frozenTurns: 0
                                };
                                break;
                            }
                        }
                    }
                }
            }

            // ç¡®ä¿è‡³å°‘æœ‰ä¸€äº›åˆå§‹æ•°å­—ï¼ˆå¦‚æœå¤ªå°‘ï¼Œå†è¡¥å……ä¸€äº›ï¼‰
            let filledCount = 0;
            for (let row = 0; row < BOARD_SIZE; row++) {
                for (let col = 0; col < BOARD_SIZE; col++) {
                    if (newBoard[row][col].value > 0) {
                        filledCount++;
                    }
                }
            }

            // å¦‚æœå¡«å……çš„æ ¼å­å°‘äº20ä¸ªï¼Œå¼ºåˆ¶è¡¥å……åˆ°è‡³å°‘20ä¸ª
            if (filledCount < 20) {
                const emptyCells = [];
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (newBoard[row][col].value === 0) {
                            emptyCells.push({ row, col });
                        }
                    }
                }

                // éšæœºæ‰“ä¹±ç©ºæ ¼å­
                for (let i = emptyCells.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [emptyCells[i], emptyCells[j]] = [emptyCells[j], emptyCells[i]];
                }

                let added = 0;
                for (const { row, col } of emptyCells) {
                    if (added >= 20 - filledCount) break;

                    const attempts = [];
                    for (let num = 1; num <= 9; num++) {
                        attempts.push(num);
                    }
                    // éšæœºæ‰“ä¹±å°è¯•é¡ºåº
                    for (let i = attempts.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [attempts[i], attempts[j]] = [attempts[j], attempts[i]];
                    }

                    for (const num of attempts) {
                        if (isValidPlacement(newBoard, row, col, num)) {
                            newBoard[row][col] = {
                                value: num,
                                type: CELL_TYPE.NUMBER,
                                monsterType: null,
                                frozenTurns: 0
                            };
                            added++;
                            break;
                        }
                    }
                }
            }

            return newBoard;
        };

        // ä¸»æ¸¸æˆç»„ä»¶
        const Game = () => {
            const [board, setBoard] = useState(() => generateInitialSudoku(initializeBoard()));
            const [inventory, setInventory] = useState(INITIAL_INVENTORY);
            const [score, setScore] = useState(0);
            const [turn, setTurn] = useState(1);
            const [playerHP, setPlayerHP] = useState(INITIAL_HP);
            const [refreshCounts, setRefreshCounts] = useState(initializeRefreshCounts());
            const [lineRewards, setLineRewards] = useState(initializeLineRewards());
            const [boxAreas, setBoxAreas] = useState(initializeBoxAreas());
            const [activeAreaEffects, setActiveAreaEffects] = useState([]);
            const [selectedNumber, setSelectedNumber] = useState(null);
            const [selectedCell, setSelectedCell] = useState(null);
            const [targetedMonster, setTargetedMonster] = useState(null); // {row, col}
            const [operationMode, setOperationMode] = useState('add'); // add æˆ– subtract
            const [gameLog, setGameLog] = useState([]);

            // ä½¿ç”¨refå­˜å‚¨å½“å‰turnå€¼ï¼Œé¿å…addLogä¾èµ–turnå¯¼è‡´æ— é™å¾ªç¯
            const turnRef = useRef(turn);
            turnRef.current = turn;

            // æ·»åŠ æ—¥å¿—
            const addLog = useCallback((message, type = 'normal') => {
                setGameLog(prev => [...prev.slice(-50), { message, type, turn: turnRef.current }]);
            }, []);

            // åˆå§‹åŒ–æ—¥å¿—
            useEffect(() => {
                const initialCount = board.flat().filter(c => c.value > 0).length;
                addLog(`æ¸¸æˆå¼€å§‹ï¼æ£‹ç›˜å·²é¢„ç½® ${initialCount} ä¸ªæ•°å­—ã€‚`, 'success');
                addLog('å®Œæˆè¡Œåˆ—æˆ–ä¹å®«æ ¼å¯ä»¥è·å¾—æ•°å­—å¥–åŠ±ã€‚', 'success');
                addLog('ç‚¹å‡»æ€ªç‰©å¯ä»¥ç„å‡†å®ƒï¼Œå®Œæˆåä¼šå‡»æ€è¢«ç„å‡†çš„æ€ªç‰©ã€‚', 'success');
                addLog('è­¦å‘Šï¼šå½“æ•°å­—åº“å­˜è€—å°½æ—¶ï¼Œæ¸¸æˆç»“æŸï¼', 'danger');
                addLog('æç¤ºï¼šæ•°å­—æ ¼å­>=10ä¼šç”Ÿæˆæ€ªç‰©ï¼Œ>=20ä¼šç”Ÿæˆç²¾è‹±æ€ªç‰©ã€‚', 'warning');
            }, []);

            // æ£€æŸ¥ç„å‡†çš„æ€ªç‰©æ˜¯å¦è¿˜å­˜åœ¨
            useEffect(() => {
                if (targetedMonster) {
                    const { row, col } = targetedMonster;
                    if (board[row][col].type !== CELL_TYPE.MONSTER) {
                        setTargetedMonster(null);
                        addLog('ç„å‡†çš„æ€ªç‰©å·²æ¶ˆå¤±', 'warning');
                    }
                }
            }, [board]);

            // æ£€æŸ¥å¹¶å®Œæˆè¡Œ/åˆ—/ä¹å®«æ ¼
            const checkCompletions = useCallback((currentBoard, startingInventory = null) => {
                let newInventory = startingInventory ? { ...startingInventory } : { ...inventory };
                let completedAreas = [];
                let damageTaken = 0;
                let hasCompleted = false; // è·Ÿè¸ªæ˜¯å¦æœ‰ä»»ä½•å®Œæˆ

                // å‡»æ€ç„å‡†çš„æ€ªç‰©å‡½æ•°
                const killTargetedMonster = () => {
                    if (targetedMonster) {
                        const { row, col } = targetedMonster;
                        if (currentBoard[row][col].type === CELL_TYPE.MONSTER) {
                            const monsterType = currentBoard[row][col].monsterType;
                            const monsterName = monsterType === MONSTER_TYPE.ELITE ? 'ç²¾è‹±æ€ªç‰©' : 'æ€ªç‰©';
                            const reward = monsterType === MONSTER_TYPE.ELITE ? 50 : 20;
                            addLog(`ğŸ¯ ç„å‡†å‡»æ€ï¼š${monsterName}ï¼ˆ${row + 1}, ${col + 1}ï¼‰+${reward}åˆ†`, 'success');
                            setScore(prev => prev + reward);

                            // ç§»é™¤æ€ªç‰©
                            currentBoard[row][col] = {
                                value: 0,
                                type: CELL_TYPE.EMPTY,
                                monsterType: null,
                                frozenTurns: 0
                            };

                            // æ¸…é™¤ç„å‡†
                            setTargetedMonster(null);
                        } else {
                            addLog('ç„å‡†çš„ç›®æ ‡å·²ä¸å­˜åœ¨', 'warning');
                            setTargetedMonster(null);
                        }
                    }
                };

                // æ£€æŸ¥è¡Œ
                for (let row = 0; row < BOARD_SIZE; row++) {
                    const values = [];
                    let hasEmpty = false;
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        if (currentBoard[row][col].value === 0) {
                            hasEmpty = true;
                            break;
                        }
                        values.push(currentBoard[row][col].value);
                    }

                    if (!hasEmpty) {
                        const uniqueValues = new Set(values);
                        if (uniqueValues.size === 9) {
                            // è¡Œå®Œæˆ
                            hasCompleted = true;
                            addLog(`ç¬¬${row + 1}è¡Œå®Œæˆï¼`, 'success');
                            const reward = lineRewards.rows[row];  // ä½¿ç”¨éšæœºçš„å¥–åŠ±æ•°å­—å’Œæ•°é‡
                            newInventory[reward.number] = (newInventory[reward.number] || 0) + reward.count;
                            addLog(`è·å¾—å¥–åŠ±ï¼š${reward.number} x ${reward.count}`, 'success');
                            setScore(prev => prev + 100);

                            // å‡»æ€ç„å‡†çš„æ€ªç‰©
                            killTargetedMonster();

                            // åˆ·æ–°è¯¥è¡Œ
                            if (refreshCounts.rows[row] > 0) {
                                let skippedFrozen = 0;
                                let clearedCells = 0;
                                for (let col = 0; col < BOARD_SIZE; col++) {
                                    // è·³è¿‡å†»ç»“çš„æ ¼å­
                                    if (currentBoard[row][col].frozenTurns > 0) {
                                        skippedFrozen++;
                                        continue;
                                    }
                                    // è®°å½•æ¸…ç©ºçš„æ ¼å­
                                    if (currentBoard[row][col].value > 0 || currentBoard[row][col].type === CELL_TYPE.MONSTER) {
                                        clearedCells++;
                                    }
                                    currentBoard[row][col] = {
                                        value: 0,
                                        type: CELL_TYPE.EMPTY,
                                        monsterType: null,
                                        frozenTurns: 0
                                    };
                                }
                                setRefreshCounts(prev => ({
                                    ...prev,
                                    rows: prev.rows.map((count, idx) => idx === row ? count - 1 : count)
                                }));
                                addLog(`ç¬¬${row + 1}è¡Œåˆ·æ–°ï¼šæ¸…ç©º${clearedCells}ä¸ªæ ¼å­`, 'normal');
                                if (skippedFrozen > 0) {
                                    addLog(`è·³è¿‡äº†${skippedFrozen}ä¸ªå†»ç»“çš„æ ¼å­`, 'warning');
                                }
                            } else {
                                // é”å®šè¯¥è¡Œï¼Œæ‰€æœ‰æ ¼å­å†»ç»“
                                for (let col = 0; col < BOARD_SIZE; col++) {
                                    currentBoard[row][col].frozenTurns = 5;
                                }
                                addLog(`ç¬¬${row + 1}è¡Œåˆ·æ–°æ¬¡æ•°è€—å°½ï¼Œå·²é”å®š`, 'warning');
                            }
                        } else {
                            // æœ‰å†²çªï¼Œæ‰£è¡€
                            damageTaken += 1;
                        }
                    }
                }

                // æ£€æŸ¥åˆ—
                for (let col = 0; col < BOARD_SIZE; col++) {
                    const values = [];
                    let hasEmpty = false;
                    for (let row = 0; row < BOARD_SIZE; row++) {
                        if (currentBoard[row][col].value === 0) {
                            hasEmpty = true;
                            break;
                        }
                        values.push(currentBoard[row][col].value);
                    }

                    if (!hasEmpty) {
                        const uniqueValues = new Set(values);
                        if (uniqueValues.size === 9) {
                            // åˆ—å®Œæˆ
                            hasCompleted = true;
                            addLog(`ç¬¬${col + 1}åˆ—å®Œæˆï¼`, 'success');
                            const reward = lineRewards.cols[col];  // ä½¿ç”¨éšæœºçš„å¥–åŠ±æ•°å­—å’Œæ•°é‡
                            newInventory[reward.number] = (newInventory[reward.number] || 0) + reward.count;
                            addLog(`è·å¾—å¥–åŠ±ï¼š${reward.number} x ${reward.count}`, 'success');
                            setScore(prev => prev + 100);

                            // å‡»æ€ç„å‡†çš„æ€ªç‰©
                            killTargetedMonster();

                            // åˆ·æ–°è¯¥åˆ—
                            if (refreshCounts.cols[col] > 0) {
                                let skippedFrozen = 0;
                                let clearedCells = 0;
                                for (let row = 0; row < BOARD_SIZE; row++) {
                                    // è·³è¿‡å†»ç»“çš„æ ¼å­
                                    if (currentBoard[row][col].frozenTurns > 0) {
                                        skippedFrozen++;
                                        continue;
                                    }
                                    // è®°å½•æ¸…ç©ºçš„æ ¼å­
                                    if (currentBoard[row][col].value > 0 || currentBoard[row][col].type === CELL_TYPE.MONSTER) {
                                        clearedCells++;
                                    }
                                    currentBoard[row][col] = {
                                        value: 0,
                                        type: CELL_TYPE.EMPTY,
                                        monsterType: null,
                                        frozenTurns: 0
                                    };
                                };
                                setRefreshCounts(prev => ({
                                    ...prev,
                                    cols: prev.cols.map((count, idx) => idx === col ? count - 1 : count)
                                }));
                                addLog(`ç¬¬${col + 1}åˆ—åˆ·æ–°ï¼šæ¸…ç©º${clearedCells}ä¸ªæ ¼å­`, 'normal');
                                if (skippedFrozen > 0) {
                                    addLog(`è·³è¿‡äº†${skippedFrozen}ä¸ªå†»ç»“çš„æ ¼å­`, 'warning');
                                }
                            } else {
                                // é”å®šè¯¥åˆ—ï¼Œæ‰€æœ‰æ ¼å­å†»ç»“
                                for (let row = 0; row < BOARD_SIZE; row++) {
                                    currentBoard[row][col].frozenTurns = 5;
                                }
                                addLog(`ç¬¬${col + 1}åˆ—åˆ·æ–°æ¬¡æ•°è€—å°½ï¼Œå·²é”å®š`, 'warning');
                            }
                        } else {
                            // æœ‰å†²çªï¼Œæ‰£è¡€
                            damageTaken += 1;
                        }
                    }
                }

                // æ£€æŸ¥ä¹å®«æ ¼
                for (let boxRow = 0; boxRow < 3; boxRow++) {
                    for (let boxCol = 0; boxCol < 3; boxCol++) {
                        const values = [];
                        let hasEmpty = false;
                        let cells = [];

                        for (let r = boxRow * 3; r < boxRow * 3 + 3; r++) {
                            for (let c = boxCol * 3; c < boxCol * 3 + 3; c++) {
                                cells.push({ row: r, col: c });
                                if (currentBoard[r][c].value === 0) {
                                    hasEmpty = true;
                                    break;
                                }
                                values.push(currentBoard[r][c].value);
                            }
                        }

                        if (!hasEmpty) {
                            const uniqueValues = new Set(values);
                            if (uniqueValues.size === 9) {
                                const boxIndex = boxRow * 3 + boxCol;
                                const areaType = boxAreas[boxIndex];

                                hasCompleted = true;
                                addLog(`ä¹å®«æ ¼${boxIndex + 1}å®Œæˆï¼`, 'success');

                                // å‡»æ€ç„å‡†çš„æ€ªç‰©
                                killTargetedMonster();

                                // æ ¹æ®åŒºåŸŸç±»å‹ç»™äºˆå¥–åŠ±
                                if (areaType === AREA_TYPE.FARM) {
                                    addLog('æ¿€æ´»å†œåœºæ•ˆæœï¼šæ¯å›åˆæ²»ç–—2ç‚¹', 'success');
                                    completedAreas.push({ type: AREA_TYPE.FARM, turns: 3 });
                                } else if (areaType === AREA_TYPE.MINE) {
                                    addLog('æ¿€æ´»çŸ¿æ´æ•ˆæœï¼šæ¯å›åˆè·å¾—2ä¸ªéšæœºæ•°å­—', 'success');
                                    completedAreas.push({ type: AREA_TYPE.MINE, turns: 3 });
                                } else if (areaType === AREA_TYPE.FACTORY) {
                                    addLog('æ¿€æ´»å·¥å‚æ•ˆæœï¼šæ¯å›åˆè·å¾—10åˆ†', 'success');
                                    completedAreas.push({ type: AREA_TYPE.FACTORY, turns: 3 });
                                }

                                // ç»™äºˆæ•°å­—å¥–åŠ±ï¼ˆå‡å°‘æ•°é‡ï¼‰
                                const rewardCount = 4;  // ä»9ä¸ªå‡å°‘åˆ°4ä¸ª
                                const rewardNumbers = [];
                                for (let i = 0; i < rewardCount; i++) {
                                    const num = Math.floor(Math.random() * 9) + 1;
                                    newInventory[num] = (newInventory[num] || 0) + 1;
                                    rewardNumbers.push(num);
                                }
                                addLog(`è·å¾—å¥–åŠ±ï¼š${rewardNumbers.join(', ')} å„1ä¸ª`, 'success');
                                setScore(prev => prev + 150);

                                // å†»ç»“æ‰€æœ‰æ ¼å­
                                for (const cell of cells) {
                                    // å¦‚æœæ ¼å­é‡Œæœ‰æ€ªç‰©ï¼Œå…ˆç§»é™¤æ€ªç‰©å¹¶è®°å½•
                                    if (currentBoard[cell.row][cell.col].type === CELL_TYPE.MONSTER) {
                                        const monsterType = currentBoard[cell.row][cell.col].monsterType;
                                        const monsterName = monsterType === MONSTER_TYPE.ELITE ? 'ç²¾è‹±æ€ªç‰©' : 'æ€ªç‰©';
                                        addLog(`ä¹å®«æ ¼å†»ç»“ï¼š${monsterName}è¢«å›°åœ¨å†°ä¸­ï¼ˆ${cell.row + 1}, ${cell.col + 1}ï¼‰`, 'warning');
                                        setScore(prev => prev + (monsterType === MONSTER_TYPE.ELITE ? 50 : 20));
                                    }
                                    // å†»ç»“æ ¼å­ï¼ˆæ— è®ºæ˜¯ä»€ä¹ˆç±»å‹ï¼Œéƒ½å˜æˆå†»ç»“çš„ç©ºæ ¼ï¼‰
                                    currentBoard[cell.row][cell.col] = {
                                        value: currentBoard[cell.row][cell.col].value,
                                        type: CELL_TYPE.NUMBER,  // æ ‡è®°ä¸ºæ•°å­—æ ¼ï¼ˆå†»ç»“ï¼‰
                                        monsterType: null,
                                        frozenTurns: 3
                                    };
                                }
                            } else {
                                // æœ‰å†²çªï¼Œæ‰£è¡€
                                damageTaken += 1;
                            }
                        }
                    }
                }

                if (damageTaken > 0) {
                    addLog(`æ•°å­—å†²çªé€ æˆ ${damageTaken} ç‚¹ä¼¤å®³ï¼`, 'danger');
                    setPlayerHP(prev => Math.max(0, prev - damageTaken));
                }

                // æ·»åŠ åŒºåŸŸæ•ˆæœï¼ˆé™åˆ¶åŒç±»å‹åªèƒ½æœ‰ä¸€ä¸ªï¼‰
                setActiveAreaEffects(prev => {
                    const newEffects = [...prev];
                    for (const newEffect of completedAreas) {
                        // æ£€æŸ¥æ˜¯å¦å·²æœ‰åŒç±»å‹çš„æ•ˆæœ
                        const existingIndex = newEffects.findIndex(e => e.type === newEffect.type);
                        if (existingIndex !== -1) {
                            // å·²æœ‰åŒç±»å‹æ•ˆæœï¼Œé‡ç½®ä¸º3å›åˆ
                            newEffects[existingIndex].turns = newEffect.turns;
                            addLog(`${newEffect.type === AREA_TYPE.FARM ? 'å†œåœº' : newEffect.type === AREA_TYPE.MINE ? 'çŸ¿æ´' : 'å·¥å‚'}æ•ˆæœé‡ç½®ä¸º${newEffects[existingIndex].turns}å›åˆ`, 'success');
                        } else {
                            // æ²¡æœ‰åŒç±»å‹æ•ˆæœï¼Œæ·»åŠ æ–°æ•ˆæœ
                            newEffects.push(newEffect);
                        }
                    }
                    return newEffects;
                });

                return { board: currentBoard, inventory: newInventory };
            }, [inventory, refreshCounts, boxAreas, lineRewards, addLog, targetedMonster]);

            // æ”¾ç½®æ•°å­—
            const placeNumber = useCallback((row, col) => {
                if (selectedNumber === null) {
                    addLog('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ•°å­—', 'warning');
                    return;
                }

                const cell = board[row][col];

                // æ£€æŸ¥æ˜¯å¦å†»ç»“
                if (cell.frozenTurns > 0) {
                    addLog('è¯¥æ ¼å­å·²å†»ç»“ï¼Œæ— æ³•æ“ä½œ', 'warning');
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰åº“å­˜
                if (inventory[selectedNumber] <= 0) {
                    addLog(`æ•°å­—${selectedNumber}åº“å­˜ä¸è¶³`, 'warning');
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦æ˜¯æ€ªç‰©æ ¼ï¼ˆä¸èƒ½æ”¾ç½®æ•°å­—ï¼‰
                if (cell.type === CELL_TYPE.MONSTER) {
                    addLog(`æ— æ³•åœ¨æ€ªç‰©æ ¼ä¸Šæ”¾ç½®æ•°å­—ï¼è¯·å…ˆå®Œæˆè¡Œ/åˆ—/ä¹å®«æ ¼å‡»æ€å®ƒã€‚`, 'danger');
                    setSelectedNumber(null);
                    setSelectedCell(null);
                    return;
                }

                const newBoard = board.map(row => row.map(cell => ({ ...cell })));
                const newValue = operationMode === 'add'
                    ? cell.value + selectedNumber
                    : Math.max(0, cell.value - selectedNumber);

                // æ¶ˆè€—æ•°å­—
                const newInventory = { ...inventory };
                newInventory[selectedNumber]--;

                if (cell.value === 0) {
                    // æ”¾ç½®åˆ°ç©ºæ ¼
                    newBoard[row][col] = {
                        value: selectedNumber,
                        type: CELL_TYPE.NUMBER,
                        monsterType: null,
                        frozenTurns: 0
                    };
                    addLog(`åœ¨(${row + 1}, ${col + 1})æ”¾ç½®æ•°å­—${selectedNumber}`, 'normal');
                } else {
                    // å¯¹å·²æœ‰æ•°å­—è¿›è¡Œè¿ç®—
                    newBoard[row][col].value = newValue;
                    addLog(`åœ¨(${row + 1}, ${col + 1})${operationMode === 'add' ? 'åŠ ' : 'å‡'}${selectedNumber}ï¼Œç»“æœä¸º${newValue}`, 'normal');

                    // æ£€æŸ¥æ˜¯å¦ç”Ÿæˆæ€ªç‰©ï¼ˆæ¦‚ç‡æ€§ï¼‰
                    if (newValue >= 20 && cell.type !== CELL_TYPE.MONSTER) {
                        // >=20å¿…ç„¶è½¬ä¸ºç²¾è‹±æ€ªç‰©
                        newBoard[row][col].type = CELL_TYPE.MONSTER;
                        newBoard[row][col].monsterType = MONSTER_TYPE.ELITE;
                        addLog(`(${row + 1}, ${col + 1})ç”Ÿæˆç²¾è‹±æ€ªç‰©ï¼`, 'danger');
                    } else if (newValue >= 10 && newValue < 20 && cell.type !== CELL_TYPE.MONSTER) {
                        // 10-19ä¹‹é—´ï¼Œ60%æ¦‚ç‡ç”Ÿæˆæ€ªç‰©
                        if (Math.random() < 0.6) {
                            newBoard[row][col].type = CELL_TYPE.MONSTER;
                            newBoard[row][col].monsterType = MONSTER_TYPE.NORMAL;
                            addLog(`(${row + 1}, ${col + 1})ç”Ÿæˆæ™®é€šæ€ªç‰©ï¼`, 'danger');
                        } else {
                            addLog(`(${row + 1}, ${col + 1})å¹¸è¿ï¼æ²¡æœ‰ç”Ÿæˆæ€ªç‰©`, 'success');
                        }
                    }
                }

                // æ£€æŸ¥æ˜¯å¦é€ æˆå†²çªï¼ˆç«‹å³æ‰£è¡€ï¼‰
                const conflicts = checkConflictsAt(newBoard, row, col);
                if (conflicts > 0) {
                    const damage = conflicts;
                    addLog(`æ•°å­—å†²çªé€ æˆ ${damage} ç‚¹ä¼¤å®³ï¼`, 'danger');
                    setPlayerHP(prev => Math.max(0, prev - damage));
                }

                setSelectedNumber(null);
                setSelectedCell(null);

                // æ£€æŸ¥å®Œæˆæƒ…å†µï¼Œä¼ å…¥å·²ç»å‡å°‘åº“å­˜çš„inventory
                const completionResult = checkCompletions(newBoard, newInventory);

                setBoard(completionResult.board);
                setInventory(completionResult.inventory);

                // æ¨è¿›å›åˆ
                setTurn(prev => {
                    const newTurn = prev + 1;
                    turnRef.current = newTurn;
                    return newTurn;
                });
            }, [selectedNumber, inventory, board, operationMode, checkCompletions, addLog]);

            // å›åˆç»“æŸå¤„ç†
            useEffect(() => {
                if (turn === 1) return; // ç¬¬ä¸€å›åˆä¸æ‰§è¡Œ

                const newBoard = board.map(row => row.map(cell => ({ ...cell })));
                let totalDamage = 0;
                let spawnedMonsters = 0;

                // å¤„ç†æ€ªç‰©æˆé•¿å’Œæ”»å‡»
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const cell = newBoard[row][col];

                        // æ€ªç‰©è¡ŒåŠ¨
                        if (cell.type === CELL_TYPE.MONSTER) {
                            // è‡ªèº«å’Œ4é‚»åŸŸ+1
                            cell.value += 1;
                            const neighbors = [
                                [row - 1, col],
                                [row + 1, col],
                                [row, col - 1],
                                [row, col + 1]
                            ];
                            for (const [nr, nc] of neighbors) {
                                if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                                    newBoard[nr][nc].value += 1;
                                }
                            }

                            // é€ æˆä¼¤å®³ï¼ˆå¢åŠ æ€ªç‰©ä¼¤å®³ï¼‰
                            const damage = cell.monsterType === MONSTER_TYPE.ELITE ? 5 : 2;
                            totalDamage += damage;
                        }

                        // è§£å†»å¤„ç†
                        if (cell.frozenTurns > 0) {
                            cell.frozenTurns--;
                            if (cell.frozenTurns === 0 && cell.type !== CELL_TYPE.MONSTER) {
                                cell.value = 0;
                                cell.type = CELL_TYPE.EMPTY;
                            }
                        }
                    }
                }

                // æ£€æŸ¥æ€ªç‰©æˆé•¿åæ˜¯å¦æœ‰æ ¼å­éœ€è¦è½¬æ¢ä¸ºæ€ªç‰©
                for (let row = 0; row < BOARD_SIZE; row++) {
                    for (let col = 0; col < BOARD_SIZE; col++) {
                        const cell = newBoard[row][col];
                        if (cell.type !== CELL_TYPE.MONSTER) {
                            if (cell.value >= 20) {
                                // >=20å¿…ç„¶è½¬ä¸ºç²¾è‹±æ€ªç‰©
                                newBoard[row][col].type = CELL_TYPE.MONSTER;
                                newBoard[row][col].monsterType = MONSTER_TYPE.ELITE;
                                addLog(`(${row + 1}, ${col + 1})å› æ€ªç‰©å½±å“ç”Ÿæˆç²¾è‹±æ€ªç‰©ï¼`, 'danger');
                                spawnedMonsters++;
                            } else if (cell.value >= 10 && cell.value < 20) {
                                // 10-19èŒƒå›´ï¼š60%æ¦‚ç‡ç”Ÿæˆæ€ªç‰©
                                if (Math.random() < 0.6) {
                                    newBoard[row][col].type = CELL_TYPE.MONSTER;
                                    newBoard[row][col].monsterType = MONSTER_TYPE.NORMAL;
                                    addLog(`(${row + 1}, ${col + 1})å› æ€ªç‰©å½±å“ç”Ÿæˆæ€ªç‰©ï¼`, 'danger');
                                    spawnedMonsters++;
                                }
                            }
                        }
                    }
                }

                // éšæœºäº‹ä»¶ï¼šæ ¼å­æ•°å­—+1ï¼ˆå¢åŠ æ¦‚ç‡ï¼‰
                if (Math.random() < 0.2) {
                    const randomRow = Math.floor(Math.random() * BOARD_SIZE);
                    const randomCol = Math.floor(Math.random() * BOARD_SIZE);
                    newBoard[randomRow][randomCol].value += 1;
                    addLog(`éšæœºäº‹ä»¶ï¼š(${randomRow + 1}, ${randomCol + 1})æ•°å­—+1`, 'warning');

                    // æ£€æŸ¥æ˜¯å¦ç”Ÿæˆæ€ªç‰©ï¼ˆæ¦‚ç‡æ€§ï¼‰
                    if (newBoard[randomRow][randomCol].value >= 20 &&
                        newBoard[randomRow][randomCol].type !== CELL_TYPE.MONSTER) {
                        newBoard[randomRow][randomCol].type = CELL_TYPE.MONSTER;
                        newBoard[randomRow][randomCol].monsterType = MONSTER_TYPE.ELITE;
                        addLog(`(${randomRow + 1}, ${randomCol + 1})ç”Ÿæˆç²¾è‹±æ€ªç‰©ï¼`, 'danger');
                        spawnedMonsters++;
                    } else if (newBoard[randomRow][randomCol].value >= 10 &&
                        newBoard[randomRow][randomCol].value < 20 &&
                        newBoard[randomRow][randomCol].type !== CELL_TYPE.MONSTER) {
                        // 60%æ¦‚ç‡ç”Ÿæˆæ€ªç‰©
                        if (Math.random() < 0.6) {
                            newBoard[randomRow][randomCol].type = CELL_TYPE.MONSTER;
                            newBoard[randomRow][randomCol].monsterType = MONSTER_TYPE.NORMAL;
                            addLog(`(${randomRow + 1}, ${randomCol + 1})ç”Ÿæˆæ€ªç‰©ï¼`, 'danger');
                            spawnedMonsters++;
                        } else {
                            addLog(`(${randomRow + 1}, ${randomCol + 1})å¹¸è¿é€ƒè„±ï¼`, 'success');
                        }
                    }
                }

                // éšæœºç”Ÿæˆæ€ªç‰©ï¼ˆå¢åŠ æ¦‚ç‡åˆ°15%ï¼‰
                if (Math.random() < 0.15) {
                    const emptyCells = [];
                    for (let row = 0; row < BOARD_SIZE; row++) {
                        for (let col = 0; col < BOARD_SIZE; col++) {
                            if (newBoard[row][col].type === CELL_TYPE.EMPTY) {
                                emptyCells.push({ row, col });
                            }
                        }
                    }
                    if (emptyCells.length > 0) {
                        const { row, col } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                        newBoard[row][col].type = CELL_TYPE.MONSTER;
                        newBoard[row][col].monsterType = MONSTER_TYPE.NORMAL;
                        newBoard[row][col].value = 5;
                        addLog(`éšæœºç”Ÿæˆæ€ªç‰©åœ¨(${row + 1}, ${col + 1})`, 'danger');
                        spawnedMonsters++;
                    }
                }

                // æ¯10å›åˆå¢åŠ åˆ·æ–°æ¬¡æ•°ï¼ˆå»¶é•¿é—´éš”ï¼‰
                if (turn % 10 === 0) {
                    setRefreshCounts(prev => ({
                        rows: prev.rows.map(count => Math.min(count + 1, 3)),
                        cols: prev.cols.map(count => Math.min(count + 1, 3))
                    }));
                    addLog('æ‰€æœ‰è¡Œåˆ—çš„åˆ·æ–°æ¬¡æ•°+1', 'success');
                }

                // å¤„ç†åŒºåŸŸæ•ˆæœ
                setActiveAreaEffects(prevEffects => {
                    // åˆ›å»ºæ–°æ•°ç»„ï¼Œæ­£ç¡®å¤„ç†å›åˆæ•°å‡å°‘
                    const newEffects = prevEffects.map(effect => ({
                        ...effect,
                        turns: effect.turns - 1
                    })).filter(effect => {
                        // åªå¤„ç†å›åˆæ•°>0çš„æ•ˆæœ
                        if (effect.turns <= 0) return false;

                        // åº”ç”¨æ•ˆæœ
                        if (effect.type === AREA_TYPE.FARM) {
                            setPlayerHP(prevHP => Math.min(INITIAL_HP, prevHP + 2));  // æé«˜åˆ°2ç‚¹
                            addLog(`å†œåœºæ•ˆæœï¼šæ²»ç–—2ç‚¹ï¼ˆå‰©ä½™${effect.turns}å›åˆï¼‰`, 'success');
                        } else if (effect.type === AREA_TYPE.MINE) {
                            setInventory(prevInv => {
                                const newInv = { ...prevInv };
                                const numbers = [];
                                for (let i = 0; i < 2; i++) {
                                    const num = Math.floor(Math.random() * 9) + 1;
                                    newInv[num] = (newInv[num] || 0) + 1;
                                    numbers.push(num);
                                }
                                addLog(`â›ï¸ çŸ¿æ´æ•ˆæœï¼šè·å¾—${numbers.join(',')}ï¼ˆå‰©ä½™${effect.turns}å›åˆï¼‰`, 'success');
                                return newInv;
                            });
                        } else if (effect.type === AREA_TYPE.FACTORY) {
                            setScore(prev => prev + 10);
                            addLog(`å·¥å‚æ•ˆæœï¼šè·å¾—10åˆ†ï¼ˆå‰©ä½™${effect.turns}å›åˆï¼‰`, 'success');
                        }

                        return true;
                    });

                    return newEffects;
                });

                // åº”ç”¨ä¼¤å®³
                if (totalDamage > 0) {
                    addLog(`æ€ªç‰©é€ æˆ ${totalDamage} ç‚¹ä¼¤å®³ï¼`, 'danger');
                    setPlayerHP(prev => Math.max(0, prev - totalDamage));
                }

                setBoard(newBoard);
            }, [turn]);

            // è·³è¿‡å›åˆ
            const skipTurn = () => {
                setTurn(prev => {
                    const newTurn = prev + 1;
                    turnRef.current = newTurn;
                    return newTurn;
                });
                addLog('è·³è¿‡å›åˆ', 'normal');
            };

            // é€‰æ‹©æ ¼å­
            const selectCell = (row, col) => {
                const cell = board[row][col];

                // å¦‚æœå·²é€‰æ‹©æ•°å­—ï¼Œæ”¾ç½®æ•°å­—
                if (selectedNumber !== null) {
                    placeNumber(row, col);
                    return;
                }

                // å¦‚æœç‚¹å‡»çš„æ˜¯æ€ªç‰©ï¼Œè®¾ç½®/å–æ¶ˆç„å‡†
                if (cell.type === CELL_TYPE.MONSTER) {
                    if (targetedMonster?.row === row && targetedMonster?.col === col) {
                        // å–æ¶ˆç„å‡†
                        setTargetedMonster(null);
                        addLog(`å–æ¶ˆç„å‡†æ€ªç‰©`, 'normal');
                    } else {
                        // è®¾ç½®ç„å‡†
                        setTargetedMonster({ row, col });
                        const monsterName = cell.monsterType === MONSTER_TYPE.ELITE ? 'ç²¾è‹±æ€ªç‰©' : 'æ€ªç‰©';
                        addLog(`ç„å‡†äº†${monsterName}ï¼å®Œæˆåä¼šå‡»æ€å®ƒ`, 'success');
                    }
                    setSelectedCell(null);
                } else {
                    // æ™®é€šæ ¼å­ï¼Œé€‰æ‹©/å–æ¶ˆé€‰æ‹©
                    setSelectedCell(selectedCell?.row === row && selectedCell?.col === col ? null : { row, col });
                    // å¦‚æœé€‰æ‹©æ–°æ ¼å­ï¼Œæ¸…é™¤ç„å‡†
                    setTargetedMonster(null);
                }
            };

            // æ¸²æŸ“å•ä¸ªæ ¼å­
            const renderCell = (row, col) => {
                const cell = board[row][col];
                const border = isBoxBorder(row, col);
                const isSelected = selectedCell?.row === row && selectedCell?.col === col;
                const isTargeted = targetedMonster?.row === row && targetedMonster?.col === col;

                // æ£€æŸ¥æ˜¯å¦æ˜¯ä¹å®«æ ¼çš„å·¦ä¸Šè§’
                const isBoxCorner = row % 3 === 0 && col % 3 === 0;
                const boxIndex = getBoxIndex(row, col);
                const areaType = boxAreas[boxIndex];

                // æ ¹æ®åŒºåŸŸç±»å‹è®¾ç½®èƒŒæ™¯è‰²
                const getAreaBackgroundColor = () => {
                    if (cell.type === CELL_TYPE.MONSTER) return '#ffebee';
                    if (cell.frozenTurns > 0) return '#e1f5fe';
                    if (areaType === AREA_TYPE.FARM) return '#c8e6c9';  // æ·±ç»¿è‰²
                    if (areaType === AREA_TYPE.MINE) return '#ffe0b2';  // æ·±æ©™è‰²
                    if (areaType === AREA_TYPE.FACTORY) return '#b3e5fc';  // æ·±è“è‰²
                    return cell.type === CELL_TYPE.EMPTY ? '#f0f0f0' : '#e3f2fd';
                };

                let cellClass = `cell ${cell.type}`;
                if (cell.frozenTurns > 0) cellClass += ' frozen';
                if (border.right) cellClass += ' box-border-right';
                if (border.bottom) cellClass += ' box-border-bottom';
                if (isSelected) cellClass += ' selected';
                if (isTargeted) cellClass += ' targeted';

                return (
                    <div
                        key={`${row}-${col}`}
                        className={cellClass}
                        onClick={() => selectCell(row, col)}
                        style={{
                            backgroundColor: getAreaBackgroundColor()
                        }}
                    >
                        {cell.value > 0 ? cell.value : ''}
                        {cell.frozenTurns > 0 && <span style={{ fontSize: '10px', position: 'absolute', bottom: '1px' }}>{cell.frozenTurns}</span>}
                        {isTargeted && <span style={{ fontSize: '12px', position: 'absolute', top: '1px', left: '1px' }}>ğŸ¯</span>}
                        {isBoxCorner && (
                            <span style={{
                                fontSize: '11px',
                                position: 'absolute',
                                top: '1px',
                                right: '1px',
                                opacity: 0.8
                            }}>
                                {areaType === AREA_TYPE.FARM ? 'ğŸŒ¾' :
                                    areaType === AREA_TYPE.MINE ? 'â›ï¸' :
                                        areaType === AREA_TYPE.FACTORY ? 'ğŸ­' : ''}
                            </span>
                        )}
                    </div>
                );
            };

            // æ£€æŸ¥æ•°å­—æ˜¯å¦è€—å°½
            const totalInventory = Object.values(inventory).reduce((sum, count) => sum + count, 0);
            const isOutOfNumbers = totalInventory === 0 && turn > 1;  // ç¬¬1å›åˆä¸æ£€æŸ¥

            // æ¸¸æˆç»“æŸ
            if (playerHP <= 0 || isOutOfNumbers) {
                const deathReason = playerHP <= 0 ? 'ä½ è¢«æ€ªç‰©å‡»è´¥äº†ï¼' : 'ä½ çš„æ•°å­—å·²ç»ç”¨å®Œäº†ï¼';
                const deathIcon = playerHP <= 0 ? 'ğŸ’€' : 'ğŸ“¦';

                return (
                    <div className="container">
                        <h1>æ¸¸æˆç»“æŸ</h1>
                        <div className="panel" style={{ textAlign: 'center', padding: '40px' }}>
                            <h2 style={{ fontSize: '32px', marginBottom: '20px' }}>{deathIcon}</h2>
                            <p style={{ fontSize: '24px', marginBottom: '10px' }}>{deathReason}</p>
                            <p style={{ fontSize: '20px', color: '#667eea' }}>æœ€ç»ˆå¾—åˆ†ï¼š{score}</p>
                            <p style={{ fontSize: '16px', color: '#666' }}>å­˜æ´»å›åˆï¼š{turn}</p>
                            <button
                                className="btn btn-primary"
                                style={{ marginTop: '20px', padding: '15px 30px', fontSize: '18px' }}
                                onClick={() => window.location.reload()}
                            >
                                é‡æ–°å¼€å§‹
                            </button>
                        </div>
                    </div>
                );
            }

            return (
                <div className="container">
                    <h1>ğŸ® æ•°ç‹¬</h1>

                    <div className="game-layout">
                        <div className="board-section">
                            <div className="sudoku-board">
                                {/* å·¦ä¸Šè§’ç©ºç™½ */}
                                <div className="corner-label"></div>

                                {/* åˆ—æ ‡ç­¾ */}
                                {board[0].map((_, colIndex) => (
                                    <div key={`col-${colIndex}`} className="col-label">
                                        <span className="line-number">{colIndex + 1}</span>
                                        <span className="reward-number">
                                            ğŸ{lineRewards.cols[colIndex].number}Ã—{lineRewards.cols[colIndex].count}
                                        </span>
                                        <span className={`refresh-count ${refreshCounts.cols[colIndex] === 0 ? 'zero' : ''}`}>
                                            åˆ·æ–°{refreshCounts.cols[colIndex]}
                                        </span>
                                    </div>
                                ))}

                                {/* è¡Œæ ‡ç­¾å’Œæ ¼å­ */}
                                {board.map((row, rowIndex) => {
                                    const elements = [];

                                    // è¡Œæ ‡ç­¾
                                    elements.push(
                                        <div key={`row-${rowIndex}`} className="row-label">
                                            <span className="line-number">{rowIndex + 1}</span>
                                            <span className="reward-number">
                                                ğŸ{lineRewards.rows[rowIndex].number}Ã—{lineRewards.rows[rowIndex].count}
                                            </span>
                                            <span className={`refresh-count ${refreshCounts.rows[rowIndex] === 0 ? 'zero' : ''}`}>
                                                åˆ·æ–°{refreshCounts.rows[rowIndex]}
                                            </span>
                                        </div>
                                    );

                                    // è¯¥è¡Œçš„æ‰€æœ‰æ ¼å­
                                    for (let colIndex = 0; colIndex < 9; colIndex++) {
                                        elements.push(renderCell(rowIndex, colIndex));
                                    }

                                    return elements;
                                })}
                            </div>

                            <div style={{ marginTop: '20px', textAlign: 'center' }}>
                                <p><strong>æ“ä½œè¯´æ˜ï¼š</strong></p>
                                <p style={{ fontSize: '14px', color: '#666' }}>
                                    1. ç‚¹å‡»ä¸‹æ–¹æ•°å­—é€‰æ‹©è¦æ”¾ç½®çš„æ•°å­—<br />
                                    2. ç‚¹å‡»æ£‹ç›˜æ ¼å­æ”¾ç½®æ•°å­—<br />
                                    3. å¯¹å·²æœ‰æ•°å­—æ ¼å¯ä»¥è¿›è¡ŒåŠ /å‡è¿ç®—<br />
                                    4. å®Œæˆè¡Œ/åˆ—/ä¹å®«æ ¼è·å¾—å¥–åŠ±
                                </p>
                                <p style={{ marginTop: '15px', fontWeight: 'bold' }}>ä¹å®«æ ¼åŒºåŸŸï¼š</p>
                                <div style={{ display: 'flex', justifyContent: 'center', gap: '10px', flexWrap: 'wrap', fontSize: '12px' }}>
                                    <span style={{ background: '#c8e6c9', padding: '4px 8px', borderRadius: '3px' }}>ğŸŒ¾ å†œåœºï¼ˆæ²»ç–—2ç‚¹ï¼‰</span>
                                    <span style={{ background: '#ffe0b2', padding: '4px 8px', borderRadius: '3px' }}>â›ï¸ çŸ¿æ´ï¼ˆ2ä¸ªæ•°å­—ï¼‰</span>
                                    <span style={{ background: '#b3e5fc', padding: '4px 8px', borderRadius: '3px' }}>ğŸ­ å·¥å‚ï¼ˆ10åˆ†ï¼‰</span>
                                </div>
                            </div>
                        </div>

                        <div className="sidebar">
                            <div className="panel">
                                <h2>ğŸ“Š çŠ¶æ€</h2>
                                <div className="stats">
                                    <div className="stat">
                                        <div className="stat-label">åˆ†æ•°</div>
                                        <div className="stat-value">{score}</div>
                                    </div>
                                    <div className="stat">
                                        <div className="stat-label">å›åˆ</div>
                                        <div className="stat-value">{turn}</div>
                                    </div>
                                    <div className="stat">
                                        <div className="stat-label">ç”Ÿå‘½å€¼</div>
                                        <div className="stat-value" style={{ color: playerHP < 30 ? '#f44336' : '#667eea' }}>
                                            {playerHP}
                                        </div>
                                    </div>
                                    <div className="stat">
                                        <div className="stat-label">æ•°å­—æ€»æ•°</div>
                                        <div className="stat-value" style={{
                                            color: totalInventory < 5 ? '#f44336' : totalInventory < 10 ? '#ff9800' : '#4caf50'
                                        }}>
                                            {totalInventory}
                                        </div>
                                    </div>
                                    <div className="stat">
                                        <div className="stat-label">æ€ªç‰©æ•°</div>
                                        <div className="stat-value" style={{ color: '#ef5350' }}>
                                            {board.flat().filter(c => c.type === CELL_TYPE.MONSTER).length}
                                        </div>
                                    </div>
                                </div>
                                {targetedMonster && (
                                    <div style={{ marginTop: '10px', padding: '8px', background: '#ffebee', borderRadius: '5px', textAlign: 'center' }}>
                                        <div style={{ fontSize: '12px', color: '#666' }}>ğŸ¯ å½“å‰ç„å‡†</div>
                                        <div style={{ fontSize: '14px', fontWeight: 'bold', color: '#f44336' }}>
                                            {(() => {
                                                const cell = board[targetedMonster.row][targetedMonster.col];
                                                const monsterName = cell.monsterType === MONSTER_TYPE.ELITE ? 'ç²¾è‹±æ€ªç‰©' : 'æ€ªç‰©';
                                                return `${monsterName} (${targetedMonster.row + 1}, ${targetedMonster.col + 1})`;
                                            })()}
                                        </div>
                                    </div>
                                )}
                                {activeAreaEffects.length > 0 && (
                                    <div style={{ marginTop: '10px', padding: '8px', background: '#e3f2fd', borderRadius: '5px' }}>
                                        <div style={{ fontSize: '12px', color: '#666', textAlign: 'center' }}>âœ¨ æ¿€æ´»æ•ˆæœ</div>
                                        {activeAreaEffects.map((effect, idx) => {
                                            const icon = effect.type === AREA_TYPE.FARM ? 'ğŸŒ¾' :
                                                effect.type === AREA_TYPE.MINE ? 'â›ï¸' :
                                                    effect.type === AREA_TYPE.FACTORY ? 'ğŸ­' : '';
                                            const name = effect.type === AREA_TYPE.FARM ? 'å†œåœº' :
                                                effect.type === AREA_TYPE.MINE ? 'çŸ¿æ´' :
                                                    effect.type === AREA_TYPE.FACTORY ? 'å·¥å‚' : '';
                                            return (
                                                <div key={idx} style={{ fontSize: '11px', color: '#667eea', textAlign: 'center', marginTop: '4px' }}>
                                                    {icon} {name} {effect.turns}å›åˆ
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}
                            </div>

                            <div className="panel">
                                <h2>ğŸ’ æ•°å­—åº“å­˜</h2>
                                <div className="inventory">
                                    {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(num => (
                                        <div
                                            key={num}
                                            className={`inventory-item ${selectedNumber === num ? 'selected' : ''}`}
                                            onClick={() => setSelectedNumber(selectedNumber === num ? null : num)}
                                        >
                                            <div className="inventory-number">{num}</div>
                                            <div className="inventory-count">x{inventory[num] || 0}</div>
                                        </div>
                                    ))}
                                </div>

                                <div className="mode-selector" style={{ marginTop: '15px' }}>
                                    <button
                                        className={`mode-btn ${operationMode === 'add' ? 'active' : ''}`}
                                        onClick={() => setOperationMode('add')}
                                    >
                                        â• åŠ æ³•æ¨¡å¼
                                    </button>
                                    <button
                                        className={`mode-btn ${operationMode === 'subtract' ? 'active' : ''}`}
                                        onClick={() => setOperationMode('subtract')}
                                    >
                                        â– å‡æ³•æ¨¡å¼
                                    </button>
                                </div>
                            </div>

                            <div className="panel">
                                <h2>ğŸ® æ§åˆ¶</h2>
                                <div className="controls">
                                    <button className="btn btn-secondary" onClick={skipTurn}>
                                        â­ï¸ è·³è¿‡å›åˆ
                                    </button>
                                    <button className="btn btn-danger" onClick={() => window.location.reload()}>
                                        ğŸ”„ é‡æ–°å¼€å§‹
                                    </button>
                                </div>
                            </div>

                            <div className="panel">
                                <h2>ğŸ“œ æ¸¸æˆæ—¥å¿—</h2>
                                <div className="game-log">
                                    {gameLog.slice().reverse().map((entry, idx) => (
                                        <div key={idx} className={`log-entry ${entry.type}`}>
                                            <strong>[T{entry.turn}]</strong> {entry.message}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // æ¸²æŸ“åº”ç”¨
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Game />);
    </script>
</body>

</html>